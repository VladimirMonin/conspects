
## SQLite3 - Библиотека Python

Библиотека `sqlite3` в Python — это встроенный модуль, предоставляющий интерфейс для работы с базами данных SQLite. SQLite — это легковесная дисковая база данных, не требующая отдельного серверного процесса для работы. Это делает ее идеальной для приложений, требующих встроенной базы данных с минимальными требованиями к системным ресурсам, таких как мобильные приложения, небольшие веб-проекты и настольные приложения.

### Основные концепции

- **Встроенность:** SQLite является встроенной СУБД, что означает, что она полностью содержится в одном исполняемом файле без необходимости во внешних серверах или процессах.
- **База данных как файл:** Вся база данных SQLite, включая таблицы, индексы, триггеры и т. д., хранится в одном файле на диске. Это упрощает управление базой данных, так как для создания резервной копии, переноса или восстановления базы данных достаточно скопировать или переместить файл.
- **Транзакции:** SQLite поддерживает транзакции, что обеспечивает согласованность данных даже в случае сбоев системы или отключения питания. Транзакции в SQLite соответствуют стандарту ACID (атомарность, согласованность, изоляция, долговечность).
- **Мультиязычность:** SQLite поддерживает множество типов данных SQL, включая текст, числа, даты и булевы значения.

### Как работает

- **Подключение к базе данных:** Чтобы начать работу с базой данных SQLite в Python, необходимо сначала создать соединение с файлом базы данных. Если файл не существует, SQLite автоматически создаст его.
- **Создание объекта курсора:** После установления соединения вы создаете объект курсора, который позволяет выполнять SQL-запросы к базе данных.
- **Выполнение SQL-запросов:** С помощью методов курсора можно выполнять различные SQL-запросы для управления данными и структурой базы данных, включая запросы на выборку (SELECT), вставку (INSERT), обновление (UPDATE) и удаление (DELETE), а также для управления схемой базы данных, например, создание или удаление таблиц.
- **Фиксация транзакций:** После выполнения изменяющих данные операций (например, INSERT, UPDATE, DELETE) необходимо зафиксировать транзакцию, чтобы изменения были сохранены в базе данных.
- **Закрытие соединения:** После завершения работы с базой данных соединение следует закрыть, чтобы освободить системные ресурсы.

### Типы запросов

Библиотека `sqlite3` поддерживает широкий спектр SQL-запросов, включая:
- **DDL (Data Definition Language):** Запросы для определения или изменения структуры базы данных, например, CREATE TABLE для создания таблиц, ALTER TABLE для изменения таблиц, DROP TABLE для удаления таблиц.
- **DML (Data Manipulation Language):** Запросы для управления данными, включая INSERT для добавления данных, UPDATE для изменения данных и DELETE для удаления данных.
- **DQL (Data Query Language):** Запросы SELECT для выборки данных из базы данных.
- **Транзакционные операции:** Включают BEGIN TRANSACTION для начала транзакции, COMMIT для ее завершения и сохранения изменений, а также ROLLBACK для отмены изменений в рамках текущей транзакции.

Библиотека `sqlite3` в Python предоставляет удобный и эффективный интерфейс для работы с базами данных SQLite, делая ее отличным выбором для множества приложений, требующих легковесных и надежных решений для хранения данных.

Библиотека `sqlite3` в Python предоставляет простые и мощные инструменты для работы с базами данных SQLite. Давайте разберемся с основами этой библиотеки, включая подключение к базе данных, основные объекты и методы, а также примеры использования.

### Основные инструменты и объекты

1. **Подключение к базе данных**: Для начала работы с базой данных SQLite необходимо установить соединение. Это делается с помощью функции `connect()`, которая принимает в качестве аргумента путь к файлу базы данных. Если файл не существует, SQLite создаст его.

   ```python
   import sqlite3
   conn = sqlite3.connect('example.db')
   ```
   Этот код создает (или открывает, если он уже существует) файл базы данных `example.db`.



2. **Объект курсора**: Для выполнения SQL-запросов используется объект курсора. Курсор создается вызовом метода `cursor()` объекта соединения.

   ```python
   cursor = conn.cursor()
   ```
   С помощью курсора можно выполнять запросы к базе данных.

3. **Выполнение SQL-запросов**: SQL-запросы выполняются с помощью метода `execute()` объекта курсора.

   - **Создание таблицы**:
     ```python
     cursor.execute('''CREATE TABLE if not exists inventory
                       (item_id INTEGER PRIMARY KEY, name TEXT, quantity INTEGER)''')
     ```
     Этот запрос создает таблицу `inventory` с тремя столбцами: `item_id`, `name` и `quantity`.

   - **Вставка данных**:
     ```python
     cursor.execute("INSERT INTO inventory (name, quantity) VALUES ('Apple', 3)")
     ```
     Добавляет в таблицу `inventory` запись с названием товара 'Apple' и количеством 3.

   - **Выборка данных**:
     ```python
     cursor.execute("SELECT * FROM inventory")
     print(cursor.fetchall())
     ```
     Выбирает все записи из таблицы `inventory` и выводит их на экран. Метод `fetchall()` возвращает все строки из последнего выполненного запроса.

4. **Фиксация транзакций**: После выполнения операций, изменяющих данные (например, INSERT, UPDATE, DELETE), необходимо вызвать метод `commit()` объекта соединения, чтобы изменения были сохранены в базе данных.

   ```python
   conn.commit()
   ```

5. **Закрытие соединения**: По завершении работы с базой данных следует закрыть соединение с помощью метода `close()`.

   ```python
   conn.close()
   ```

### Методы объекта курсора и соединения

- **`cursor.execute(sql, [parameters])`**: Выполняет один SQL-запрос. Параметры можно передать вторым аргументом для предотвращения SQL-инъекций.
- **`cursor.executemany(sql, seq_of_parameters)`**: Позволяет выполнить SQL-запрос многократно с разными значениями параметров.
- **`cursor.fetchall()`**: Возвращает все строки результата последнего запроса.
- **`cursor.fetchone()`**: Возвращает следующую строку результата запроса.
- **`conn.commit()`**: Сохраняет все изменения, сделанные в транзакции.
- **`conn.close()`**: Закрывает соединение с базой данных.

Эти основные инструменты и методы обеспечивают весь необходимый функционал для работы с базами данных SQLite в Python, позволяя легко выполнять операции создания, чтения, обновления и удаления данных (CRUD).


Методы объекта курсора в библиотеке `sqlite3` предоставляют различные способы взаимодействия с базой данных SQLite. Основные методы включают `execute()`, `executemany()`, и `executescript()`. Каждый из них имеет свои особенности и применяется в соответствующих сценариях.

### `execute()`

Метод `execute()` используется для выполнения одного SQL-запроса. Это может быть запрос на выборку данных, вставку, обновление, удаление или операции с структурой базы данных, такие как создание или удаление таблиц.

- **Особенности**:
  - Позволяет передавать параметры в запрос, что делает его удобным для предотвращения SQL-инъекций.
  - Параметры передаются в виде кортежа или словаря.
  - Возвращает сам объект курсора, что позволяет цепочечно вызывать другие методы, например, `fetchone()` или `fetchall()` для получения результатов запроса.

```python
conn.execute("PRAGMA foreign_keys = ON;")
```
Этот параметр **позволяет включить проверку ссылочной целостности в SQLite.** Когда он включен, SQLite будет проверять, что все внешние ключи имеют соответствующие родительские ключи при выполнении операций INSERT и UPDATE, и предотвращать действия, которые нарушают ссылочную целостность. Это полезно для обеспечения целостности данных в базе данных.

### `executemany()`

Метод `executemany()` принимает SQL-запрос и последовательность параметров и выполняет этот запрос многократно, подставляя каждый раз новый набор параметров. Это особенно полезно для вставки или обновления множества записей одним вызовом.

- **Особенности**:
  - Повышает эффективность операций пакетной обработки данных по сравнению с многократным вызовом `execute()`.
  - Не делает автокоммиты. В SQLite транзакция начинается автоматически перед серией операций вставки/обновления/удаления и должна быть явно завершена вызовом `commit()` на объекте соединения для фиксации изменений.
  - Возвращает объект курсора.

### `executescript()`

Метод `executescript()` предназначен для выполнения множества SQL-запросов за один вызов. В отличие от `execute()` и `executemany()`, этот метод может выполнять несколько SQL-запросов, разделенных точкой с запятой, что делает его идеальным для выполнения SQL-скриптов.

Пример кода 

для использования метода `executescript()`:

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# SQL-скрипт, содержащий несколько запросов
script = '''
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER
);

INSERT INTO users (name, age) VALUES ('Alice', 30);
INSERT INTO users (name, age) VALUES ('Bob', 25);
'''

# Выполнение SQL-скрипта с помощью executescript()
cursor.executescript(script)

# Сохранение изменений и закрытие соединения
conn.commit()
conn.close()
```

В этом примере мы создаем базу данных SQLite и выполняем SQL-скрипт, который создает таблицу `users` и добавляет две записи в эту таблицу. Метод `executescript()` позволяет выполнить оба SQL-запроса за один вызов.

- **Особенности**:
  - Автоматически выполняет коммит перед началом выполнения и после завершения всех запросов в скрипте. Это означает, что если в скрипте содержится несколько операций, изменяющих данные, изменения будут автоматически сохранены после выполнения скрипта.
  - Подходит для выполнения сложных скриптов с множеством последовательных операций, включая создание или модификацию структуры базы данных и манипуляции с данными.
  - Возвращает объект курсора.

### Дополнительная важная информация

- **Параметризация запросов**: Все три метода поддерживают параметризованные запросы, что помогает защитить от SQL-инъекций. Параметры в `execute()` и `executemany()` можно передавать как позиционные, так и именованные.
- **Управление транзакциями**: SQLite использует механизм логических блокировок для управления транзакциями. По умолчанию, каждый отдельный SQL-запрос выполняется в рамках своей транзакции, если только не было явно начато выполнение транзакции. Понимание этого механизма важно для эффективного управления транзакциями и

 избежания потери данных.
- **Производительность**: Использование `executemany()` для пакетной вставки или обновления данных может значительно повысить производительность по сравнению с многократным вызовом `execute()` для каждой записи. Однако стоит помнить, что открытая транзакция может блокировать таблицу для других операций, поэтому важно своевременно выполнять `commit()`.

Понимание этих методов и их особенностей поможет эффективно работать с базами данных SQLite в Python, обеспечивая высокую производительность и безопасность ваших приложений.


### Автокоммит в `executemany` и SQLite

В контексте SQLite и библиотеки `sqlite3` в Python, автокоммит является частью управления транзакциями. По умолчанию, SQLite работает в режиме автокоммита, когда каждая операция SQL запускается в своей транзакции и автоматически фиксируется. Однако, использование `executemany` само по себе не вызывает автокоммит после каждой вставки. Автокоммит происходит, если не была явно начата транзакция. Если нужно отключить автокоммит во время использования `executemany`, можно явно начать транзакцию с помощью `BEGIN TRANSACTION` и завершить её вызовом `commit()` после выполнения `executemany`.

### `cursor.fetchone()`

Метод `fetchone()` используется для извлечения одной строки из результата запроса. Если строк больше нет, он возвращает `None`. Это полезно, когда необходимо обрабатывать результат запроса построчно.

**Пример использования:**

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполнение запроса
cursor.execute("SELECT * FROM inventory")

# Извлечение одной строки
row = cursor.fetchone()

# Обработка результата
if row:
    print(row)
else:
    print("No more rows")

# Закрытие соединения
conn.close()
```

### `conn.commit()`

Метод `commit()` используется для сохранения всех изменений, сделанных в рамках текущей транзакции, в базу данных. Он фиксирует изменения и делает их постоянными. Этот метод следует вызывать после операций, изменяющих данные (например, INSERT, UPDATE, DELETE).

**Пример использования:**

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполнение запроса на изменение данных
cursor.execute("INSERT INTO inventory (name, quantity) VALUES ('Orange', 5)")

# Фиксация изменений
conn.commit()

# Закрытие соединения
conn.close()
```

### `conn.close()`

Метод `close()` используется для закрытия соединения с базой данных. Это освобождает ресурсы, связанные с соединением. Рекомендуется всегда закрывать соединение после завершения работы с базой данных.

**Пример использования:**

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполнение запроса на выборку данных
cursor.execute("SELECT * FROM inventory")
rows = cursor.fetchall()

# Обработка результата
for row in rows:
    print(row)

# Закрытие соединения
conn.close()
```

### Особенности работы с коммитами в SQLite с использованием sqlite3

В SQLite управление транзакциями и фиксацией изменений играет важную роль для обеспечения целостности данных. Вот несколько ключевых аспектов, которые следует учитывать:

- **Автокоммит**: По умолчанию, SQLite работает в режиме автокоммита. Это означает, что каждая SQL-команда, выполняемая вне явной транзакции, автоматически фиксируется сразу после выполнения. Это удобно для простых операций, но для сложных последовательностей изменений рекомендуется использовать явные транзакции.
  
- **Явные транзакции**: Для выполнения нескольких операций в рамках одной транзакции можно использовать команды `BEGIN TRANSACTION`, `COMMIT` и `ROLLBACK`. Это позволяет гарантировать, что все изменения будут зафиксированы только если все операции в транзакции прошли успешно.

**Пример использования явных транзакций:**

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Начало транзакции
conn.execute("BEGIN TRANSACTION")

try:
    # Выполнение нескольких запросов
    cursor.execute("INSERT INTO inventory (name, quantity) VALUES ('Banana', 10)")
    cursor.execute("UPDATE inventory SET quantity = quantity + 5 WHERE name = 'Apple'")
    
    # Фиксация изменений
    conn.commit()
except sqlite3.Error as e:
    # Откат транзакции в случае ошибки
    conn.rollback()
    print("Transaction failed: ", e)

# Закрытие соединения
conn.close()
```

- **Параллелизм и блокировки**: SQLite использует блокировки для управления параллельным доступом к базе данных. Во время выполнения транзакции таблица может быть заблокирована для других операций. Это важно учитывать при проектировании приложений с параллельным доступом к базе данных.

- **Постепенные изменения**: Для эффективного управления большими объемами данных рекомендуется использовать методы пакетной обработки, такие как `executemany()`, в сочетании с явными транзакциями. Это позволяет снизить накладные расходы на блокировки и повысить производительность.

Понимание этих аспектов поможет эффективно управлять транзакциями и обеспечивать целостность данных при работе с SQLite в Python.


## SQL инъекция

### Что такое SQL-инъекции?

SQL-инъекции — это метод атаки, при котором злоумышленник вводит вредоносный SQL-код в поля ввода веб-приложения. Цель этой атаки — выполнить нежелательные SQL-запросы к базе данных, получить доступ к данным, изменить их или даже уничтожить. SQL-инъекции являются одной из самых распространенных и опасных уязвимостей веб-приложений.

### Как происходит SQL-инъекция?

SQL-инъекция обычно происходит, когда приложение не проверяет или не очищает вводимые данные и напрямую вставляет их в SQL-запрос. Рассмотрим пример:

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Ввод пользователя
user_input = "1 OR 1=1"

# Уязвимый SQL-запрос
query = f"SELECT * FROM users WHERE id = {user_input}"
cursor.execute(query)

# Извлечение данных
rows = cursor.fetchall()
for row in rows:
    print(row)

# Закрытие соединения
conn.close()
```

Если злоумышленник вводит `1 OR 1=1`, запрос станет `SELECT * FROM users WHERE id = 1 OR 1=1`, что приведет к выборке всех строк из таблицы `users`, так как `1=1` всегда истинно. Это может привести к утечке конфиденциальной информации.

### Как бороться с SQL-инъекциями в Python с использованием sqlite3?

1. **Использование параметризованных запросов**: Вместо того чтобы включать пользовательский ввод непосредственно в SQL-запрос, используйте параметризованные запросы. Библиотека `sqlite3` поддерживает это с помощью заполнителей `?` или `:param_name`.

2. **Проверка и очистка данных**: Проверяйте и очищайте все входные данные, чтобы убедиться, что они соответствуют ожидаемому формату.

3. **Ограничение прав доступа**: Минимизируйте привилегии, предоставленные учетной записи базы данных, используемой вашим приложением, чтобы ограничить потенциальный ущерб от успешной атаки.

### Пример защиты с помощью параметризованных запросов

Использование параметризованных запросов значительно снижает риск SQL-инъекций, так как вводимые данные обрабатываются как параметры, а не как часть SQL-запроса.

**Пример использования параметризованных запросов:**

```python
import sqlite3

# Подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Ввод пользователя
user_input = "1 OR 1=1"

# Безопасный SQL-запрос с параметром
query = "SELECT * FROM users WHERE id = ?"
cursor.execute(query, (user_input,))

# Извлечение данных
rows = cursor.fetchall()
for row in rows:
    print(row)

# Закрытие соединения
conn.close()
```

В этом примере пользовательский ввод передается в качестве параметра, и SQLite обрабатывает его безопасно, предотвращая выполнение вредоносного кода.

### Дополнительные меры безопасности

- **Использование ORM**: Использование ORM (Object-Relational Mapping) библиотек, таких как SQLAlchemy или Django ORM, также помогает предотвратить SQL-инъекции, так как они автоматически параметризуют запросы.

- **Логи и мониторинг**: Внедрение системы логирования и мониторинга, чтобы обнаружить подозрительные действия и потенциальные атаки.

### Заключение

SQL-инъекции представляют серьезную угрозу безопасности, но правильные методы программирования и использования библиотеки `sqlite3` в Python могут эффективно защитить ваше приложение. Использование параметризованных запросов, проверка и очистка данных, а также минимизация прав доступа — ключевые шаги для обеспечения безопасности вашей базы данных.

### Параллелизм и блокировки в SQLite

SQLite поддерживает параллельный доступ к базе данных, но с определенными ограничениями, связанными с одновременным доступом на чтение и запись. Важно понимать различные уровни блокировки, которые используются в SQLite:

1. **Блокировка базы данных (Database Lock)**:
   - SQLite использует механизм блокировок для управления доступом к базе данных и обеспечения целостности данных.
   - Есть три основных уровня блокировки:
     - **SHARED (совместная блокировка)**: Используется для операций чтения. Несколько транзакций могут одновременно удерживать совместную блокировку.
     - **RESERVED (зарезервированная блокировка)**: Используется, когда транзакция планирует внести изменения, но еще не начала их фиксировать. Она позволяет другим транзакциям продолжать чтение, но предотвращает другие записи.
     - **EXCLUSIVE (исключительная блокировка)**: Используется для операций записи. Только одна транзакция может удерживать исключительную блокировку, что предотвращает любые другие транзакции (чтение и запись) до завершения текущей транзакции.

2. **Параллельный доступ на чтение и запись**:
   - SQLite позволяет нескольким потокам или процессам одновременно читать базу данных.
   - Однако только один поток или процесс может записывать данные в базу данных в любой момент времени.
   - Во время записи, все операции чтения будут заблокированы до тех пор, пока запись не будет завершена.

### Особенности и практические аспекты

- **Одновременные операции чтения**: Несколько потоков или процессов могут одновременно читать из базы данных без каких-либо проблем. SQLite обрабатывает совместные блокировки для чтения, что позволяет параллельный доступ.

- **Операции записи**: Только один поток или процесс может выполнять операцию записи в базу данных в данный момент времени. Когда транзакция начинается, она устанавливает RESERVED блокировку. После подготовки изменений транзакция пытается установить EXCLUSIVE блокировку для фиксации изменений, что может блокировать другие операции до завершения транзакции.

- **Влияние на производительность**: В высококонкурентных сценариях, где часто происходят операции записи, производительность может снижаться из-за блокировок. Это особенно важно для приложений, требующих частого обновления данных.

- **Настройки многопоточности в SQLite**: SQLite можно настроить для работы в одном из трех режимов многопоточности:
  - **Single-thread**: Библиотека SQLite не использует никакие блокировки. Это безопасно только в случае, если все вызовы SQLite происходят из одного потока.
  - **Multi-thread**: Несколько потоков могут выполнять чтение, но только один поток может выполнять запись. Это режим по умолчанию.
  - **Serialized**: Все функции библиотеки SQLite безопасны для вызова из нескольких потоков одновременно. Это наиболее безопасный режим для многопоточных приложений.

Настройки можно изменить с помощью функции `sqlite3_config()` до открытия соединений с базой данных:

```python
import sqlite3

sqlite3.config(sqlite3.SQLITE_CONFIG_SERIALIZED)
conn = sqlite3.connect('example.db')
```

### Пример многопоточной программы

Пример простого многопоточного приложения, выполняющего чтение и запись в базу данных:

```python
import sqlite3
import threading

def read_data():
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM inventory")
    rows = cursor.fetchall()
    for row in rows:
        print(row)
    conn.close()

def write_data(name, quantity):
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()
    cursor.execute("INSERT INTO inventory (name, quantity) VALUES (?, ?)", (name, quantity))
    conn.commit()
    conn.close()

# Создание потоков для чтения и записи
read_thread = threading.Thread(target=read_data)
write_thread = threading.Thread(target=write_data, args=('Banana', 10))

# Запуск потоков
read_thread.start()
write_thread.start()

# Ожидание завершения потоков
read_thread.join()
write_thread.join()
```

Этот пример демонстрирует создание потоков для одновременного чтения и записи в базу данных. Однако стоит помнить, что при высокой нагрузке на запись возможны блокировки и снижение производительности.

### Заключение

SQLite обеспечивает хороший уровень параллелизма для операций чтения, но ограничивает одновременный доступ на запись для обеспечения целостности данных. Важно учитывать эти особенности при разработке многопоточных приложений и, при необходимости, использовать режимы многопоточности и стратегии управления транзакциями для оптимизации производительности и надежности приложений.

### Тестирование запросов в pytest

Для тестирования запросов к базе данных в pytest можно использовать виртуальные таблицы и фикстуры. Фикстуры с `yield` позволяют настроить тестовую среду перед выполнением теста и очистить её после, что идеально подходит для тестирования взаимодействия с базой данных.

Пример фикстуры для создания и удаления тестовой базы данных:

```python
import pytest
import sqlite3

@pytest.fixture
def db():
    conn = sqlite3.connect(":memory:")  # Создание базы данных в памяти
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE test_table (id INTEGER PRIMARY KEY, value TEXT)''')
    yield conn  # Возвращает объект соединения для использования в тесте
    conn.close()  # Закрытие соединения после завершения теста
```

Такая фикстура позволяет каждому тесту работать с собственной чистой копией базы данных, что обеспечивает изоляцию и повторяемость тестов.

### Параллельное чтение/запись в SQLite

SQLite поддерживает параллельное чтение, но запись в базу данных может производиться только одним процессом или потоком одновременно из-за механизма блокировок. Для управления конкурентным доступом SQLite использует несколько режимов изоляции транзакций, включая режим WAL (Write-Ahead Logging), который позволяет читателям продолжать чтение из базы данных в то время, как другая транзакция записывает данные.

Пример использования SQLite в Python для обеспечения конкурентного доступа в режиме WAL:

```python
import sqlite3

conn = sqlite3.connect('example.db')
conn.execute('PRAGMA journal_mode=WAL;')  # Включение режима WAL

# Теперь можно безопасно читать данные в одном потоке, в то время как другой поток выполняет запись
```

Использование режима WAL облегчает разработку приложений, где требуется высокая доступность и конкурентный доступ к базе данных

 для чтения, но всё же требует внимательного управления транзакциями для избежания конфликтов и "голодания" записывающих процессов.

Для тестирования и проверки структуры базы данных SQLite, а также для подготовки параметризированных тестов в контексте домашних заданий студентов, можно использовать ряд служебных запросов. Эти запросы позволяют извлекать информацию о таблицах, столбцах, типах данных и ключах. Давайте рассмотрим основные из них.

### Получение информации о таблицах

Чтобы получить список всех таблиц в базе данных SQLite, можно использовать следующий запрос к служебной таблице `sqlite_master`:

```sql
SELECT name FROM sqlite_master WHERE type='table';
```

Этот запрос возвращает имена всех таблиц в базе данных.

### Получение информации о столбцах таблицы

Для получения списка столбцов определенной таблицы и информации о них можно использовать запрос `PRAGMA table_info()`:

```sql
PRAGMA table_info('имя_таблицы');
```

Этот запрос вернет информацию о каждом столбце в таблице, включая идентификатор столбца, имя, тип данных, признак необходимости значения (not null) и значение по умолчанию.

### Получение информации о первичных и внешних ключах

- **Первичные ключи**: Информация о первичных ключах также возвращается запросом `PRAGMA table_info()`, где для столбцов, являющихся частью первичного ключа, будет установлено специальное значение.

- **Внешние ключи**: Для получения информации о внешних ключах таблицы можно использовать запрос `PRAGMA foreign_key_list()`:

  ```sql
  PRAGMA foreign_key_list('имя_таблицы');
  ```

  Этот запрос вернет список внешних ключей для указанной таблицы, включая имя столбца в текущей таблице, имя связанной таблицы и имя столбца в связанной таблице.

### Параметризированные тесты в pytest

Для тестирования наличия таблиц, столбцов и ключей можно использовать параметризированные тесты в `pytest`. Пример параметризации для проверки наличия таблиц:

```python
import pytest
import sqlite3

# Предположим, у нас есть функция для получения списка таблиц
def get_tables(db_path):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    tables = cursor.fetchall()
    conn.close()
    return [t[0] for t in tables]

# Параметризированный тест для проверки наличия определенных таблиц
@pytest.mark.parametrize('table_name', ['students', 'courses'])
def test_table_exists(db_path, table_name):
    assert table_name in get_tables(db_path)
```

Аналогичный подход можно использовать для тестирования наличия столбцов и проверки свойств ключей, используя служебные запросы `PRAGMA table_info()` и `PRAGMA foreign_key_list()` для получения необходимой информации и параметризацию в `pytest` для определения тестовых случаев.

Такие служебные запросы и подходы к тестированию могут быть очень полезны при автоматизации проверки структуры баз данных в домашних заданиях студентов, обеспечивая эффективную и точную проверку соответствия заданным требованиям.


Давайте разберем примеры использования методов `execute`, `executemany`, и `executescript` из библиотеки `sqlite3` в Python, объясняя каждый шаг для лучшего понимания.

### `execute` с подстановкой данных

Метод `execute` используется для выполнения одного SQL-запроса. Особенно полезен для вставки, обновления, удаления данных или выполнения запросов на выборку.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')  # Подключаемся к базе данных
cursor = conn.cursor()  # Создаем курсор

# Вставка данных с подстановкой переменных
name = 'Alice'
age = 30
cursor.execute("INSERT INTO People (name, age) VALUES (?, ?)", (name, age))

conn.commit()  # Сохраняем изменения
conn.close()  # Закрываем соединение
```
В этом примере `?` используется в качестве плейсхолдера для переменных `name` и `age`, которые подставляются в запрос. Это предотвращает SQL-инъекции и является рекомендуемым способом работы с динамическими данными.

### `executemany` для пакетной обработки

Метод `executemany` идеален для выполнения одного и того же SQL-запроса с разными значениями, например, при вставке нескольких строк данных одновременно.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Пакетная вставка данных
people = [('Bob', 25), ('Cindy', 35), ('Dave', 20)]
cursor.executemany("INSERT INTO People (name, age) VALUES (?, ?)", people)

conn.commit()
conn.close()
```
Здесь `executemany` используется для вставки нескольких записей в таблицу `People`. Каждый элемент списка `people` представляет собой кортеж, который соответствует плейсхолдерам в SQL-запросе.

### `executescript` для выполнения нескольких SQL-запросов

Метод `executescript` позволяет выполнить несколько SQL-запросов за один вызов. Это полезно для выполнения скриптов SQL, содержащих несколько команд.

**Пример**:
```python
import sqlite3

conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполнение нескольких SQL-команд
script = """
CREATE TABLE IF NOT EXISTS Products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);
INSERT INTO Products (name, price) VALUES ('Pen', 10);
INSERT INTO Products (name, price) VALUES ('Pencil', 5);
"""
cursor.executescript(script)

conn.commit()
conn.close()
```
В этом примере `executescript` используется для создания новой таблицы `Products` и вставки в нее двух строк. Метод идеально подходит для инициализации базы данных или выполнения миграций.

**Общие советы по использованию**:
- Всегда используйте подстановку переменных (`?`) в `execute` и `executemany` для предотвращения SQL-инъекций.
- После выполнения изменяющих данные операций не забудьте вызвать `commit()`, чтобы сохранить изменения.
- Закрывайте соединение с базой данных (`close()`) после выполнения всех необходимых операций для освобождения ресурсов.

Эти примеры должны дать студентам хорошее представление о том, как использовать основные методы `sqlite3` для работы с базами данных SQLite в Python.